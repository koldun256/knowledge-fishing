ПРОЕКТ: «Умная Рыбалка Знаний» (Knowledge Fishing)

ИДЕЯ
Образовательное приложение, которое закрепляет сложные знания через метафору рыбалки. Факты — это «рыбы» в тематических «прудах». Учимся через активное припоминание и интервальные повторения.

ВИЗУАЛЬНАЯ СЦЕНА
- Небо (верхняя полоса), ниже — прямоугольный пруд на весь экран.
- 4 уровня глубины (0 — мелководье, 3 — глубина). Вода — слои с собственными цветами, чёткие границы внутри сцены.
- Анимированная поверхность с волнами h(t, x) = a1 sin(f1 t + s1 x) + a2 sin(...) + a3 sin(...).
- Лодка сидит на волне, наклоняется по уклону.
- Рыбы плавают внутри своего уровня, разворачиваются до краёв, скорость/вертикальный дрейф — индивидуальны.
- Эффекты: лёгкий «задний» градиент глубины и пятна растительности; «передний» туман/взвесь/редкие пузырьки.

ПРОЦЕСС РЫБАЛКИ
1) Пользователь жмёт «Начать рыбалку».
2) Бэкенд (пока мок) возвращает целевую рыбу GET /fishes/next.
3) Анимация: крючок опускается на центр уровня цели → рыба быстро подплывает к крючку → вываживание вверх.
4) Открывается модалка с вопросом/ответом и оценкой 1–4. Пока окно открыто, рыба привязана к крючку.
5) Отправка оценки PUT /fishes/{id}/review возвращает обновлённую рыбу с новым depth_level.

API СЕРВЕРА (сейчас моками)
Базовый URL: https://api.knowledge-fishing.com/v1
Аутентификация: UUID в cookies (для моков не требуется)
Эндпоинты:
- Пруды: GET /ponds/{id}
- Рыбы: GET /ponds/{id}/fishes, GET /fishes/next, PUT /fishes/{id}/review
- Сессии: GET /fishing-sessions/

АРХИТЕКТУРА ФРОНТА
Файловая структура:
src/
  pages/Pond.jsx
  components/CanvasStage.jsx
  components/FishingDialog.jsx
  context/PondContext.jsx
  layers/waterSurface.js
  layers/underwaterBack.js
  layers/underwaterFront.js
  layers/fishes.js
  layers/fishingLine.js
  layers/boat.js
  utils/assets.js
  data/mockData.js
  services/pondService.js
  services/fishService.js
  services/sessionService.js

Контракты взаимодействия:
- CanvasStage: общий loop рендера, рендерит слои, даёт frame={ctx,t,dt,w,h,pondTop}.
- PondContext: хранит pond,fishes,boat,fishing FSM,dialog. Методы setFishing,resetFishing,setDialog,setWaveFn/getWaveFn.
- waterSurface: рисует уровни воды, регистрирует waveFn(t,x,frame).
- boat: сидит на волне, наклоняется по уклону.
- fishes: плавают сами; целевая рыба прилипает к крючку в фазах luring,reeling,done+dialog.open.
- fishingLine: управляет крючком и фазами, открывает модалку.
- FishingDialog: показывает вопрос/ответ, принимает оценку, вызывает review, закрывает, resetFishing().

КОД ФАЙЛОВ

## src/context/PondContext.jsx

// context/PondContext.jsx
import React, { createContext, useContext, useRef, useState, useMemo } from 'react';

const PondContext = createContext(null);

export function PondProvider({ children }) {
  const [pond, setPond] = useState(null);
  const [fishes, setFishes] = useState([]);
  const [boat, setBoat] = useState({ x: 200 });

  // fishing state
  const [fishing, setFishingState] = useState({
    phase: 'idle',        // 'idle' | 'casting' | 'luring' | 'reeling' | 'done'
    sessionId: null,
    targetFishId: null,
    hookX: null,
    hookY: null,
    boatX: 200,
  });

  // dialog state
  const [dialog, setDialog] = useState({
    open: false,
    fish: null,            // объект рыбы
    sessionId: null,
  });

  const setFishing = (updater) => {
    setFishingState((prev) => (typeof updater === 'function' ? updater(prev) : updater));
  };

  const resetFishing = () => {
    setFishingState({
      phase: 'idle',
      sessionId: null,
      targetFishId: null,
      hookX: null,
      hookY: null,
      boatX: boat?.x ?? 200,
    });
  };

  const stateRef = useRef({ pond: null, fishes: [], boat: { x: 200 }, fishing: null, dialog: null });
  stateRef.current = { pond, fishes, boat, fishing, dialog };

  const setBoatX = (x) => setBoat((prev) => ({ ...prev, x }));

  // волны
  const waveFnRef = useRef(null);
  const setWaveFn = (fn) => { waveFnRef.current = fn; };
  const getWaveFn = () => waveFnRef.current;

  const value = useMemo(() => ({
    pond, fishes, boat, fishing, dialog,
    setPond, setFishes, setBoatX,
    setFishing, resetFishing,
    setDialog,
    setWaveFn, getWaveFn,
    getState: () => ({
      pond, fishes, boat, fishing, dialog,
      setFishing, resetFishing, setDialog,
      setWaveFn, getWaveFn,
    }),
  }), [pond, fishes, boat, fishing, dialog]);

  return <PondContext.Provider value={value}>{children}</PondContext.Provider>;
}

export function usePond() {
  const ctx = useContext(PondContext);
  if (!ctx) throw new Error('usePond must be used within PondProvider');
  return ctx;
}


## src/components/CanvasStage.jsx

// components/CanvasStage.jsx
import React, { useRef, useEffect } from 'react';

export default function CanvasStage({
  className = 'fixed inset-0 block',
  style,
  skyRatio = 0.12,
  layers = [],
  getState, // <- возьмём из контекста
}) {
  const canvasRef = useRef(null);
  const rafRef = useRef(null);
  const lastTimeRef = useRef(0);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d', { alpha: false });
    const resize = () => {
      const w = Math.round(window.innerWidth);
      const h = Math.round(window.innerHeight);
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = `${w}px`;
      canvas.style.height = `${h}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };

    resize();
    window.addEventListener('resize', resize, { passive: true });

    const loop = (nowMs) => {
      const w = Math.round(window.innerWidth);
      const h = Math.round(window.innerHeight);
      const t = nowMs / 1000;
      const dt = lastTimeRef.current ? (nowMs - lastTimeRef.current) / 1000 : 0;
      lastTimeRef.current = nowMs;

      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, w, h);

      const frame = { ctx, t, dt, w, h, pondTop: Math.round(h * skyRatio), skyRatio };

      for (const layer of layers.sort((a, b) => (a.order ?? 0) - (b.order ?? 0))) {
        layer.draw && layer.draw(frame, getState);
      }

      rafRef.current = requestAnimationFrame(loop);
    };

    rafRef.current = requestAnimationFrame(loop);
    return () => {
      window.removeEventListener('resize', resize);
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, [layers, getState, skyRatio]);

  return <canvas ref={canvasRef} className={className} style={style} />;
}



## src/layers/waterSurface.js

export default function createWaterSurfaceLayer(options = {}) {
  const {
    stepX = 2,
    levelGradients = [
      ['#7EC8FA','#5FB4F5'],
      ['#57ABF2','#2F8EE8'],
      ['#277FD7','#1B63B9'],
      ['#134A97','#0C3877'],
    ],
    wave = { a1:6,f1:1.2,s1:0.015, a2:4,f2:2.1,s2:0.027, a3:2,f3:3.4,s3:0.042 },
  } = options;

  const crestPad = Math.ceil(Math.abs(wave.a1)+Math.abs(wave.a2)+Math.abs(wave.a3))+2;
  const waveHeight = (t, x) =>
    wave.a1*Math.sin(wave.f1*t+wave.s1*x) +
    wave.a2*Math.sin(wave.f2*t+wave.s2*x) +
    wave.a3*Math.sin(wave.f3*t+wave.s3*x);

  const splitHeights = (total, n) => {
    const base = Math.floor(total/n), rem = total - base*n;
    return Array.from({length:n}, (_,i)=> base + (i<rem?1:0));
  };

  return {
    id:'water-surface', order:10,
    draw: ({ctx,t,w,h,pondTop}, getState) => {
      const { setWaveFn } = getState?.() || {};
      setWaveFn && setWaveFn((time,x,frame)=> (frame?.pondTop??pondTop) + waveHeight(time,x));

      const pondH = Math.max(0, h-pondTop);
      const H = splitHeights(pondH,4);

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0, pondTop + waveHeight(t,0));
      for (let x=stepX; x<=w; x+=stepX) ctx.lineTo(x, pondTop + waveHeight(t,x));
      ctx.lineTo(w,h); ctx.lineTo(0,h); ctx.closePath(); ctx.clip();

      let yTop = pondTop - crestPad;
      // уровень 0
      {
        const top=yTop, bottom=top + (H[0]+crestPad);
        const g = ctx.createLinearGradient(0,top,0,bottom);
        g.addColorStop(0, levelGradients[0][0]); g.addColorStop(1, levelGradients[0][1]);
        ctx.fillStyle = g; ctx.fillRect(0, top, w, bottom-top);
        yTop = pondTop + H[0];
      }
      // уровни 1..3
      for (let i=1;i<4;i++){
        const top=yTop, bottom=top+H[i];
        const [cTop,cBot] = levelGradients[i] || levelGradients[levelGradients.length-1];
        const g = ctx.createLinearGradient(0,top,0,bottom);
        g.addColorStop(0,cTop); g.addColorStop(1,cBot);
        ctx.fillStyle = g; ctx.fillRect(0, top, w, bottom-top);
        yTop = bottom;
      }
      ctx.restore();
    }
  };
}

## src/layers/fishes.js

// layers/fishes.js
// Спрайтовые рыбы: плавают туда-сюда, не доходя до краёв,
// меняют высоту в пределах уровня. "Готовые" — цветные,
// "неготовые" — серые силуэты и плывут медленнее.
// Во время рыбалки рыба-цель подплывает к крючку и "вываживается".

import { Assets } from '../utils/assets';

export default function createFishesLayer(options = {}) {
  const {
    leftMargin = 36,
    rightMargin = 36,
    speedRangeReady = [28, 72],
    speedRangeIdle  = [18, 46],
    vertAmpRange = [6, 18],
    vertFreqRange = [0.3, 0.9],
    levelCount = 4,
    levelPadding = 8,
    sheetKey = 'fishSheet',
    SPR_W = 16,
    SPR_H = 12,
    FRAMES = 4,
    scale = 2.5,
    idleAlpha = 0.85,
    useGrayscaleFilter = true,
    // параметры "приманивания" и вываживания
    lureSpeedBoost = 220,     // скорость сближения к крючку (px/s)
    reelFollowOffset = 10,    // рыба висит чуть ниже крючка при вываживании
    lureSnapDist = 18,        // дистанция "схватился" (px)
  } = options;

  const fishState = new Map();
  const randIn = (a, b) => a + Math.random() * (b - a);
  const pickDir = () => (Math.random() < 0.5 ? -1 : 1);
  const clampLevel = (lvl, count) => Math.min(count - 1, Math.max(0, lvl | 0));
  const levelToRow = (level) => Math.min(2, Math.max(0, level)); // 3 вида в спрайте

  const levelCenterY = (level, pondTop, levelH) => {
    const top = pondTop + level * levelH + levelPadding;
    const bottom = pondTop + (level + 1) * levelH - levelPadding;
    return (top + bottom) * 0.5;
  };
  const levelRange = (level, pondTop, levelH) => {
    const top = pondTop + level * levelH + levelPadding;
    const bottom = pondTop + (level + 1) * levelH - levelPadding;
    return [top, bottom];
  };

  const ensureFishState = (f, w, pondTop, levelH, isReady) => {
    let s = fishState.get(f.id);
    if (!s) {
      const level = clampLevel(f.depth_level ?? 0, levelCount);
      s = {
        x: randIn(leftMargin + SPR_W * scale, w - rightMargin - SPR_W * scale),
        dir: pickDir(),
        speed: randIn(...(isReady ? speedRangeReady : speedRangeIdle)),
        phase: Math.random() * Math.PI * 2,
        amp: randIn(...vertAmpRange),
        freq: randIn(...vertFreqRange) * Math.PI * 2,
        level,
        centerY: levelCenterY(level, pondTop, levelH),
      };
      fishState.set(f.id, s);
    } else {
      const newLevel = clampLevel(f.depth_level ?? 0, levelCount);
      if (newLevel !== s.level) {
        s.level = newLevel;
        s.centerY = levelCenterY(newLevel, pondTop, levelH);
        s.amp = randIn(...vertAmpRange);
      }
      // подстройка скорости под готовность
      const target = randIn(...(isReady ? speedRangeReady : speedRangeIdle));
      s.speed = s.speed * 0.85 + target * 0.15;
    }
    return s;
  };

  const frameIndex = (t, speed, isReady) => {
    const baseFps = isReady ? 8 : 6;
    const plus = Math.min(6, speed / 14);
    return Math.floor(t * (baseFps + plus)) % FRAMES;
  };

  function drawSprite(ctx, img, sx, sy, sw, sh, dx, dy, flipX, scale, asGray, alpha) {
    ctx.save();
    ctx.translate(dx, dy);
    if (flipX) ctx.scale(-1, 1);
    ctx.imageSmoothingEnabled = false;
    if (asGray && useGrayscaleFilter) {
      ctx.filter = 'grayscale(100%) saturate(0%) brightness(85%)';
      ctx.globalAlpha = alpha;
    } else if (asGray) {
      ctx.globalAlpha = alpha;
    }
    ctx.drawImage(img, sx, sy, sw, sh, -sw * 0.5 * scale, -sh * 0.5 * scale, sw * scale, sh * scale);
    if (asGray && useGrayscaleFilter) ctx.filter = 'none';
    ctx.restore();
  }

  return {
    id: 'fishes',
    order: 20,
    draw: (frame, getState) => {
      const { ctx, t, dt, w, h, pondTop } = frame;
      const gs = getState?.() || {};
    const fishes = gs.fishes || [];
    const fishing = gs.fishing || {};
    const dialogOpen = !!gs.dialog?.open;

      if (!fishes.length) return;

      const pondH = Math.max(0, h - pondTop);
      const levelH = pondH / 4;
      const sheet = Assets.get(sheetKey);

      fishes.forEach((f) => {
        const isReady = !!f.ready; // Готовность берём из f.ready (bool)
        const s = ensureFishState(f, w, pondTop, levelH, isReady);

        // базовое движение (если нет захвата сценарием рыбалки)
        let overridePos = false;

        // если эта рыба — цель рыбалки
        if (fishing?.targetFishId === f.id && fishing?.phase) {
          if (fishing.phase === 'luring') {
            // быстро подплывает к крючку
            const tx = fishing.hookX;
            const ty = fishing.hookY;
            const dx = tx - s.x;
            const dy = ty - (s.centerY + Math.sin(t * s.freq + s.phase) * s.amp);
            const dist = Math.hypot(dx, dy);
            if (dist > 1e-3) {
              const vx = (dx / dist) * lureSpeedBoost;
              const vy = (dy / dist) * lureSpeedBoost;
              s.x += vx * dt;
              // верт. вести к цели без строгого ограничения диапазоном уровня (чуть свободнее)
              const newY = (s.centerY) + vy * dt;
              s.centerY = newY; // смещаем центр, чтобы рыба могла подняться/опуститься к крючку
            }
            // если почти у крючка — дальше стадия "reeling" (решает fishingLayer)
            overridePos = true; // ничего больше по базовой логике не делаем
            if (dist <= lureSnapDist && gs.setFishing) {
                gs.setFishing(prev => prev?.phase === 'luring' ? { ...prev, phase: 'reeling' } : prev);
            }
          } else if (fishing.phase === 'reeling') {
            // «прилипает» к крючку, чуть ниже
            s.x = fishing.hookX;
            s.centerY = fishing.hookY + reelFollowOffset;
            overridePos = true;
          } else if (fishing.phase === 'done' && dialogOpen) {
            // диалог открыт — рыба продолжает висеть на крючке у лодки
            s.x = fishing.hookX;
            s.centerY = fishing.hookY + reelFollowOffset;
            overridePos = true;
          }
        }

        if (!overridePos) {
          // Горизонталь + разворот до границ
          s.x += s.dir * s.speed * dt;
          const halfW = (SPR_W * scale) * 0.5;
          const leftLimit = leftMargin + halfW;
          const rightLimit = w - rightMargin - halfW;
          if (s.x <= leftLimit) { s.x = leftLimit; s.dir = 1; }
          else if (s.x >= rightLimit) { s.x = rightLimit; s.dir = -1; }

          // Вертикальные колебания внутри уровня
          const [yMin, yMax] = levelRange(s.level, pondTop, levelH);
          const yOsc = Math.sin(t * s.freq + s.phase) * s.amp;
          let ny = s.centerY + yOsc;
          if (ny < yMin) ny = yMin;
          if (ny > yMax) ny = yMax;
          s.centerY = (s.centerY * 0.9) + (ny * 0.1); // лёгкая инерция
        }

        // итоговая Y
        const y = s.centerY;

        // отрисовка
        if (sheet) {
          const row = levelToRow(s.level);
          const col = frameIndex(t, s.speed, isReady);
          const sx = col * SPR_W;
          const sy = row * SPR_H;

          // ВАЖНО: раньше рыбы «плыли задом наперёд». Меняем знак flipX:
          // flipX = (s.dir < 0)  было → стало:
          const flipX = (s.dir > 0); // теперь спрайт разворачивается корректно

          if (isReady) {
            drawSprite(ctx, sheet, sx, sy, SPR_W, SPR_H, s.x, y, flipX, scale, false, 1);
          } else {
            drawSprite(ctx, sheet, sx, sy, SPR_W, SPR_H, s.x, y, flipX, scale, true, idleAlpha);
          }
        } else {
          // fallback
          ctx.save();
          ctx.fillStyle = isReady ? '#FFD54F' : 'rgba(180,180,180,0.8)';
          ctx.beginPath();
          ctx.arc(s.x, y, SPR_H * 0.6, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      });
    },
  };
}



## src/layers/fishingLine.js

const easeOutCubic = (p)=>1-Math.pow(1-p,3);

export default function createFishingLineLayer(options={}) {
  const { lineColor='rgba(230,230,230,0.9)', hookColor='#cfd8dc', hookSize=8, castDuration=700, reelDuration=900 } = options;
  let castStart=null, reelStart=null, targetDepthY=null;

  return {
    id:'fishing-line', order:27,
    draw:(frame,getState)=>{
      const {ctx,t,w,h,pondTop}=frame;
      const gs = getState?.() || {};
      const { fishing, setFishing, setDialog, fishes, getWaveFn, dialog } = gs;
      const waveFn = getWaveFn?.() || ((time,x,fr)=>(fr?.pondTop??pondTop));

      if (!fishing || fishing.phase==='idle') { castStart=null; reelStart=null; targetDepthY=null; return; }

      const boatX = fishing.boatX ?? (w*0.5);
      const anchorY = waveFn(t, boatX, frame) - 6;

      if (fishing.phase==='casting' && castStart===null){
        const fish = fishes?.find(ff=>ff.id===fishing.targetFishId);
        const lev = Math.min(3, Math.max(0, (fish?.depth_level??0)|0));
        const L = (h-pondTop)/4;
        const top = pondTop + lev*L, bot = pondTop + (lev+1)*L;
        targetDepthY = (top+bot)*0.5;
        castStart = performance.now();
      }

      let hookX=boatX, hookY=anchorY+20;

      if (fishing.phase==='casting'){
        const p = Math.min(1, (performance.now()-castStart)/castDuration);
        const k = easeOutCubic(p);
        hookY = anchorY + (targetDepthY - anchorY)*k;
        if (p>=1) setFishing(prev=>({...prev, phase:'luring', hookX, hookY}));

      } else if (fishing.phase==='luring'){
        hookY = targetDepthY;

      } else if (fishing.phase==='reeling'){
        if (reelStart===null) reelStart=performance.now();
        const p = Math.min(1, (performance.now()-reelStart)/reelDuration);
        const k = easeOutCubic(p);
        hookY = targetDepthY + (anchorY - targetDepthY)*k;
        if (p>=1){
          const fish = fishes?.find(ff=>ff.id===fishing.targetFishId);
          setDialog && setDialog({ open:true, fish, sessionId:fishing.sessionId });
          setFishing(prev=>({...prev, phase:'done', hookX, hookY }));
        }

      } else if (fishing.phase==='done'){
        hookY = anchorY; // у лодки; координаты публикуем для «привязки» рыбы
      }

      setFishing(prev=> (prev?.phase? { ...prev, hookX, hookY } : prev));

      ctx.save();
      ctx.strokeStyle=lineColor; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(boatX, anchorY); ctx.lineTo(hookX, hookY); ctx.stroke();
      ctx.fillStyle=hookColor; ctx.beginPath(); ctx.arc(hookX, hookY, hookSize*0.2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.moveTo(hookX, hookY + hookSize*0.2); ctx.lineTo(hookX + 4, hookY + 6); ctx.strokeStyle=hookColor; ctx.stroke();
      ctx.restore();
    }
  };
}


## src/layers/boat.js

export default function createBoatLayer() {
  const hullOffset=10, tiltScale=0.04;
  return {
    id:'boat', order:30,
    draw:(frame,getState)=>{
      const {ctx,t,w} = frame;
      const { boat, getWaveFn } = getState?.() || {};
      const x = boat?.x ?? w*0.5;
      const waveFn = getWaveFn?.() || ((time,x)=>frame.pondTop);
      const ySurf = waveFn(t, x, frame);
      const yL = waveFn(t, x-1, frame), yR = waveFn(t, x+1, frame);
      const angle = Math.atan((yR-yL)/2)*tiltScale;
      const y = ySurf - hullOffset;

      ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
      ctx.fillStyle='#4E342E';
      ctx.beginPath(); ctx.moveTo(-40,0); ctx.lineTo(40,0); ctx.lineTo(30,12); ctx.lineTo(-30,12); ctx.closePath(); ctx.fill();
      ctx.strokeStyle='#1B1B1B'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(0,-22); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(50,-40); ctx.stroke();
      ctx.restore();
    }
  };
}

## src/components/FishingDialog.jsx

import React, { useEffect, useState, useCallback } from 'react';
import { usePond } from '../context/PondContext';
import { fishService } from '../services/fishService';
import { sessionService } from '../services/sessionService';

export default function FishingDialog() {
  const { dialog, setDialog, resetFishing, fishes, setFishes } = usePond();
  const [score, setScore] = useState(null);
  const [submitting, setSubmitting] = useState(false);
  const fish = dialog?.fish || null;

  // Сброс локального состояния при открытии/закрытии
  useEffect(() => {
    if (dialog.open) {
      setScore(null);
      setSubmitting(false);
    }
  }, [dialog.open]);

  // Хоткеи: 1..4 — выбрать оценку, Enter — отправить, Esc — отмена
  const onKey = useCallback((e) => {
    if (!dialog.open) return;
    if (e.key >= '1' && e.key <= '4') {
      setScore(Number(e.key));
    } else if (e.key === 'Enter' && score != null && !submitting) {
      e.preventDefault();
      handleSubmit();
    } else if (e.key === 'Escape' && !submitting) {
      handleCancel();
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dialog.open, score, submitting]);

  useEffect(() => {
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, [onKey]);

  const closeAndReset = () => {
    setDialog({ open: false, fish: null, sessionId: null });
    resetFishing(); // переведёт FSM в 'idle' и освободит крючок/рыбу
  };

  const handleCancel = () => {
    if (submitting) return;
    closeAndReset();
  };

  const handleSubmit = async () => {
    if (score == null || submitting || !fish) return;
    setSubmitting(true);
    try {
      // 1) Отправляем оценку — возвращается обновлённая рыба (новый depth_level и т.п.)
      const updated = await fishService.reviewFish(fish.id, { score });

      // 2) Обновляем локальный список рыб
      const idx = fishes.findIndex((x) => String(x.id) === String(fish.id));
      if (idx !== -1) {
        const next = fishes.slice();
        next[idx] = updated;
        setFishes(next);
      }

    } catch (err) {
      console.error('Ошибка при отправке результата:', err);
      // Можно показать тост/сообщение — пока просто закрываем диалог, чтобы не блокировать цикл
    } finally {
      setSubmitting(false);
      closeAndReset();
    }
  };

  if (!dialog.open || !fish) return null;

  return (
    <div className="fixed inset-0 z-[100] bg-black/50 flex items-center justify-center p-4">
      <div className="w-full max-w-xl bg-white rounded-lg shadow-lg p-6">
        <h2 className="text-xl font-semibold mb-2">Оцените вспоминание</h2>

        <div className="mb-3">
          <div className="text-sm text-gray-500">Вопрос</div>
          <div className="font-medium text-gray-900 whitespace-pre-wrap">
            {fish.question || '—'}
          </div>
        </div>

        <div className="mb-4">
          <div className="text-sm text-gray-500">Ответ</div>
          <div className="p-3 bg-gray-50 rounded text-gray-800 whitespace-pre-wrap">
            {fish.answer || '—'}
          </div>
        </div>

        <div className="mb-4">
          <div className="font-semibold mb-2">Насколько хорошо вы вспомнили?</div>
          <div className="grid grid-cols-4 gap-2">
            {[1, 2, 3, 4].map((v) => (
              <button
                key={v}
                onClick={() => setScore(v)}
                disabled={submitting}
                className={`py-2 rounded border transition ${
                  score === v
                    ? 'bg-blue-600 text-white border-blue-600'
                    : 'bg-white hover:bg-gray-50'
                }`}
                aria-pressed={score === v}
              >
                {v}
              </button>
            ))}
          </div>
          <p className="text-xs text-gray-500 mt-2">
            Горячие клавиши: 1–4 для выбора, Enter — отправить, Esc — отмена.
          </p>
        </div>

        <div className="flex justify-end gap-2">
          <button
            onClick={handleCancel}
            disabled={submitting}
            className="px-4 py-2 rounded border hover:bg-gray-50 disabled:opacity-50"
          >
            Отмена
          </button>
          <button
            onClick={handleSubmit}
            disabled={score == null || submitting}
            className="px-4 py-2 rounded bg-blue-600 text-white disabled:opacity-50"
          >
            {submitting ? 'Сохраняю…' : 'Сохранить'}
          </button>
        </div>
      </div>
    </div>
  );
}



## src/utils/assets.js

export const Assets = {
  images:{},
  loadImage(key, src){
    if (this.images[key]) return Promise.resolve(this.images[key]);
    return new Promise((resolve,reject)=>{
      const img=new Image();
      img.onload=()=>{ this.images[key]=img; resolve(img); };
      img.onerror=reject;
      img.src=src;
    });
  },
  get(key){ return this.images[key]; }
};


## src/services/pondService.js

import { API_CONFIG } from '../config/api';

export const pondService = {
  getAllPonds: async () => {
    const response = await fetch(`${API_CONFIG.BASE_URL}/ponds`, {
      credentials: API_CONFIG.withCredentials ? 'include' : 'omit'
    });
    if (!response.ok) throw new Error('Failed to fetch ponds');
    return response.json();
  },

  getPondById: async (id) => {
    const response = await fetch(`${API_CONFIG.BASE_URL}/ponds/${id}`, {
      credentials: API_CONFIG.withCredentials ? 'include' : 'omit'
    });
    if (!response.ok) throw new Error('Failed to fetch pond');
    return response.json();
  }
};



## src/components/Pond.jsx

// src/pages/Pond.jsx
import React, { useEffect, useMemo, useState } from 'react';

// контекст
import { PondProvider, usePond } from '../context/PondContext';

// канвас-сцена
import CanvasStage from '../components/CanvasStage';

// слои
import createWaterSurfaceLayer from '../layers/waterSurface';
import createUnderwaterBackLayer from '../layers/underwaterBack';
import createUnderwaterFrontLayer from '../layers/underwaterFront';
import createFishesLayer from '../layers/fishes';
import createFishingLineLayer from '../layers/fishingLine';
import createBoatLayer from '../layers/boat';

// диалог
import FishingDialog from '../components/FishingDialog';

// сервисы (моки)
import { pondService } from '../services/pondService';
import { fishService } from '../services/fishService';

// ассеты (спрайт рыб)
import { Assets } from '../utils/assets';

function PondInner({ pondId }) {
  const {
    pond, setPond,
    fishes, setFishes,
    getState,
    fishing, setFishing,
    boat,
    dialog,
  } = usePond();

  const [loading, setLoading] = useState(true);

  // загрузка ассетов + данных пруда/рыб
  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        setLoading(true);
        // спрайт рыб (если уже загружен — вернётся мгновенно)
        await Assets.loadImage('fishSheet', '/assets/fish_spritesheet_px.png').catch(() => {});
        // данные
        const [pondData, fishesData] = await Promise.all([
          pondService.getPondById(pondId),
          fishService.getFishesByPondId(pondId),
        ]);
        if (!cancelled) {
          setPond(pondData);
          setFishes(fishesData);
        }
      } catch (e) {
        console.error('Ошибка загрузки данных:', e);
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();
    return () => { cancelled = true; };
  }, [pondId, setPond, setFishes]);

  // слои сцены
  const layers = useMemo(() => ([
    createWaterSurfaceLayer({
      // жёсткие границы между уровнями (внутренности — сплошные цвета)
      levelGradients: [
        ['#7EC8FA', '#5FB4F5'], // уровень 0 (верх)
        ['#57ABF2', '#2F8EE8'], // уровень 1
        ['#277FD7', '#1B63B9'], // уровень 2
        ['#134A97', '#0C3877'], // уровень 3 (низ)
      ],
    }),
    createUnderwaterBackLayer({
      enableGradient: true,
      enableVegetation: true,
      enableInternalWaves: false,
      enableCaustics: false,
    }),
    createFishesLayer(), // рыбы учитывают ready из fish.ready и корректный flipX
    createUnderwaterFrontLayer({
      enableDepthFog: true,
      enableMotes: true,
      enableBubbles: true,
    }),
    createFishingLineLayer(), // крючок/леска + управление фазами и открытие диалога
    createBoatLayer(),
  ]), []);

  // запуск рыбалки (мок-API)
  const startFishing = async () => {
    try {
      // не допускаем повторного старта, пока не idle или открыт диалог
      if (fishing.phase !== 'idle' || dialog.open) return;

      const nextFish = await fishService.getNextFish();  // { id, depth_level, ready, ... } — мок

      setFishing(prev => ({
        ...prev,
        phase: 'casting',
        targetFishId: nextFish.id,
        boatX: boat?.x ?? window.innerWidth * 0.5,
        hookX: null,
        hookY: null,
      }));
    } catch (e) {
      console.error(e);
    }
  };

  if (loading) return <div className="p-8 text-center">Загрузка пруда...</div>;
  if (!pond) return <div className="p-8 text-center text-red-500">Пруд не найден</div>;

  const canStart = fishing.phase === 'idle' && !dialog.open;

  return (
    <>
      <CanvasStage
        skyRatio={0.12}
        layers={layers}
        getState={getState}
      />

      {/* Кнопка — скрыта, пока предыдущая попытка не завершена */}
      {canStart && (
        <button
          onClick={startFishing}
          className="fixed top-4 left-4 z-[60] bg-white/85 hover:bg-white text-slate-800 px-4 py-2 rounded shadow"
        >
          Начать рыбалку
        </button>
      )}

      {/* Диалог-оверлей с оценкой (1..4) */}
      <FishingDialog />
    </>
  );
}

// Экспорт страницы с провайдером контекста
export default function Pond({ pondId }) {
  return (
    <PondProvider>
      <PondInner pondId={pondId} />
    </PondProvider>
  );
}


