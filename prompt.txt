ПРОЕКТ: «Умная Рыбалка Знаний» (Knowledge Fishing)

ИДЕЯ
Образовательное приложение, которое закрепляет сложные знания через метафору рыбалки. Факты — это «рыбы» в тематических «прудах». Учимся через активное припоминание и интервальные повторения.

ВИЗУАЛЬНАЯ СЦЕНА
- Небо (верхняя полоса), ниже — прямоугольный пруд на весь экран.
- 4 уровня глубины (0 — мелководье, 3 — глубина). Вода — слои с собственными цветами, чёткие границы внутри сцены.
- Анимированная поверхность с волнами h(t, x) = a1 sin(f1 t + s1 x) + a2 sin(...) + a3 sin(...).
- Лодка сидит на волне, наклоняется по уклону.
- Рыбы плавают внутри своего уровня, разворачиваются до краёв, скорость/вертикальный дрейф — индивидуальны.
- Эффекты: лёгкий «задний» градиент глубины и пятна растительности; «передний» туман/взвесь/редкие пузырьки.

ПРОЦЕСС РЫБАЛКИ
1) Пользователь жмёт «Начать рыбалку».
2) Бэкенд (пока мок) возвращает целевую рыбу GET /fishes/next.
3) Анимация: крючок опускается на центр уровня цели → рыба быстро подплывает к крючку → вываживание вверх.
4) Открывается модалка с вопросом/ответом и оценкой 1–4. Пока окно открыто, рыба привязана к крючку.
5) Отправка оценки PUT /fishes/{id}/review возвращает обновлённую рыбу с новым depth_level.
6) Завершение сессии POST /fishing-sessions/{id}/end, закрываем модалку, FSM → idle. Кнопка старта снова доступна.

API СЕРВЕРА (сейчас моками)
Базовый URL: https://api.knowledge-fishing.com/v1
Аутентификация: UUID в cookies (для моков не требуется)
Эндпоинты:
- Пруды: GET /ponds/{id}
- Рыбы: GET /ponds/{id}/fishes, GET /fishes/next, PUT /fishes/{id}/review
- Сессии: POST /fishing-sessions/start, POST /fishing-sessions/{id}/end

АРХИТЕКТУРА ФРОНТА
Файловая структура:
src/
  pages/Pond.jsx
  components/CanvasStage.jsx
  components/FishingDialog.jsx
  context/PondContext.jsx
  layers/waterSurface.js
  layers/underwaterBack.js
  layers/underwaterFront.js
  layers/fishes.js
  layers/fishingLine.js
  layers/boat.js
  utils/assets.js
  data/mockData.js
  services/pondService.js
  services/fishService.js
  services/sessionService.js

Контракты взаимодействия:
- CanvasStage: общий loop рендера, рендерит слои, даёт frame={ctx,t,dt,w,h,pondTop}.
- PondContext: хранит pond,fishes,boat,fishing FSM,dialog. Методы setFishing,resetFishing,setDialog,setWaveFn/getWaveFn.
- waterSurface: рисует уровни воды, регистрирует waveFn(t,x,frame).
- boat: сидит на волне, наклоняется по уклону.
- fishes: плавают сами; целевая рыба прилипает к крючку в фазах luring,reeling,done+dialog.open.
- fishingLine: управляет крючком и фазами, открывает модалку.
- FishingDialog: показывает вопрос/ответ, принимает оценку, вызывает review, закрывает, resetFishing().

КОД ФАЙЛОВ

## src/context/PondContext.jsx

import React, { createContext, useContext, useRef, useState, useMemo } from 'react';

const PondContext = createContext(null);

export function PondProvider({ children }) {
  const [pond, setPond] = useState(null);
  const [fishes, setFishes] = useState([]);
  const [boat, setBoat] = useState({ x: 200 });

  const [fishing, setFishingState] = useState({
    phase: 'idle', // 'idle' | 'casting' | 'luring' | 'reeling' | 'done'
    sessionId: null,
    targetFishId: null,
    hookX: null,
    hookY: null,
    boatX: 200,
  });

  const [dialog, setDialog] = useState({
    open: false,
    fish: null,
    sessionId: null,
  });

  const setFishing = (updater) =>
    setFishingState((prev) => (typeof updater === 'function' ? updater(prev) : updater));

  const resetFishing = () => {
    setFishingState({
      phase: 'idle',
      sessionId: null,
      targetFishId: null,
      hookX: null,
      hookY: null,
      boatX: boat?.x ?? 200,
    });
  };

  const stateRef = useRef(null);
  stateRef.current = { pond, fishes, boat, fishing, dialog };

  const setBoatX = (x) => setBoat((prev) => ({ ...prev, x }));

  const waveFnRef = useRef(null);
  const setWaveFn = (fn) => { waveFnRef.current = fn; };
  const getWaveFn = () => waveFnRef.current;

  const value = useMemo(() => ({
    pond, fishes, boat, fishing, dialog,
    setPond, setFishes, setBoatX,
    setFishing, resetFishing, setDialog,
    setWaveFn, getWaveFn,
    getState: () => ({
      pond, fishes, boat, fishing, dialog,
      setFishing, resetFishing, setDialog, setWaveFn, getWaveFn,
    }),
  }), [pond, fishes, boat, fishing, dialog]);

  return <PondContext.Provider value={value}>{children}</PondContext.Provider>;
}

export function usePond() {
  const ctx = useContext(PondContext);
  if (!ctx) throw new Error('usePond must be used within PondProvider');
  return ctx;
}

## src/components/CanvasStage.jsx

import React, { useRef, useEffect } from 'react';

export default function CanvasStage({ className='fixed inset-0 block', style, skyRatio=0.12, layers=[], getState }) {
  const canvasRef = useRef(null);
  const rafRef = useRef(null);
  const lastRef = useRef(0);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d', { alpha: false });

    const resize = () => {
      const w = Math.round(window.innerWidth);
      const h = Math.round(window.innerHeight);
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = `${w}px`;
      canvas.style.height = `${h}px`;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };
    resize();
    window.addEventListener('resize', resize, { passive: true });

    const loop = (now) => {
      const w = Math.round(window.innerWidth);
      const h = Math.round(window.innerHeight);
      const t = now / 1000;
      const dt = lastRef.current ? (now - lastRef.current) / 1000 : 0;
      lastRef.current = now;

      ctx.fillStyle = '#87CEEB';
      ctx.fillRect(0, 0, w, h);

      const frame = { ctx, t, dt, w, h, pondTop: Math.round(h * skyRatio), skyRatio };

      for (const layer of layers.slice().sort((a,b)=>(a.order??0)-(b.order??0))) {
        layer.draw && layer.draw(frame, getState);
      }
      rafRef.current = requestAnimationFrame(loop);
    };

    rafRef.current = requestAnimationFrame(loop);
    return () => {
      window.removeEventListener('resize', resize);
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, [layers, getState, skyRatio]);

  return <canvas ref={canvasRef} className={className} style={style} />;
}


## src/layers/waterSurface.js

export default function createWaterSurfaceLayer(options = {}) {
  const {
    stepX = 2,
    levelGradients = [
      ['#7EC8FA','#5FB4F5'],
      ['#57ABF2','#2F8EE8'],
      ['#277FD7','#1B63B9'],
      ['#134A97','#0C3877'],
    ],
    wave = { a1:6,f1:1.2,s1:0.015, a2:4,f2:2.1,s2:0.027, a3:2,f3:3.4,s3:0.042 },
  } = options;

  const crestPad = Math.ceil(Math.abs(wave.a1)+Math.abs(wave.a2)+Math.abs(wave.a3))+2;
  const waveHeight = (t, x) =>
    wave.a1*Math.sin(wave.f1*t+wave.s1*x) +
    wave.a2*Math.sin(wave.f2*t+wave.s2*x) +
    wave.a3*Math.sin(wave.f3*t+wave.s3*x);

  const splitHeights = (total, n) => {
    const base = Math.floor(total/n), rem = total - base*n;
    return Array.from({length:n}, (_,i)=> base + (i<rem?1:0));
  };

  return {
    id:'water-surface', order:10,
    draw: ({ctx,t,w,h,pondTop}, getState) => {
      const { setWaveFn } = getState?.() || {};
      setWaveFn && setWaveFn((time,x,frame)=> (frame?.pondTop??pondTop) + waveHeight(time,x));

      const pondH = Math.max(0, h-pondTop);
      const H = splitHeights(pondH,4);

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0, pondTop + waveHeight(t,0));
      for (let x=stepX; x<=w; x+=stepX) ctx.lineTo(x, pondTop + waveHeight(t,x));
      ctx.lineTo(w,h); ctx.lineTo(0,h); ctx.closePath(); ctx.clip();

      let yTop = pondTop - crestPad;
      // уровень 0
      {
        const top=yTop, bottom=top + (H[0]+crestPad);
        const g = ctx.createLinearGradient(0,top,0,bottom);
        g.addColorStop(0, levelGradients[0][0]); g.addColorStop(1, levelGradients[0][1]);
        ctx.fillStyle = g; ctx.fillRect(0, top, w, bottom-top);
        yTop = pondTop + H[0];
      }
      // уровни 1..3
      for (let i=1;i<4;i++){
        const top=yTop, bottom=top+H[i];
        const [cTop,cBot] = levelGradients[i] || levelGradients[levelGradients.length-1];
        const g = ctx.createLinearGradient(0,top,0,bottom);
        g.addColorStop(0,cTop); g.addColorStop(1,cBot);
        ctx.fillStyle = g; ctx.fillRect(0, top, w, bottom-top);
        yTop = bottom;
      }
      ctx.restore();
    }
  };
}

## src/layers/fishes.js

import { Assets } from '../utils/assets';

export default function createFishesLayer(options = {}) {
  const {
    leftMargin=36, rightMargin=36,
    speedRangeReady=[28,72], speedRangeIdle=[18,46],
    vertAmpRange=[6,18], vertFreqRange=[0.3,0.9],
    levelCount=4, levelPadding=8,
    sheetKey='fishSheet', SPR_W=16, SPR_H=12, FRAMES=4, scale=2.5,
    idleAlpha=0.85, useGrayscaleFilter=true,
    lureSpeedBoost=220, reelFollowOffset=10, lureSnapDist=18,
  } = options;

  const fishState = new Map();
  const rnd=(a,b)=>a+Math.random()*(b-a);
  const dir=()=> (Math.random()<0.5?-1:1);
  const clampLev=(l,c)=>Math.min(c-1,Math.max(0,l|0));
  const levelToRow=(l)=>Math.min(2,Math.max(0,l));

  const centerY=(lev, top, h)=> {
    const L = (h)/levelCount;
    const t = top + lev*L + levelPadding;
    const b = top + (lev+1)*L - levelPadding;
    return (t+b)*0.5;
  };
  const rangeY=(lev, top, h)=> {
    const L = (h)/levelCount;
    return [ top + lev*L + levelPadding, top + (lev+1)*L - levelPadding ];
  };

  const ensure = (f, w, pondTop, pondH, ready) => {
    let s = fishState.get(f.id);
    const lev = clampLev(f.depth_level ?? 0, levelCount);
    if(!s){
      s = {
        x: rnd(leftMargin + SPR_W*scale, w - rightMargin - SPR_W*scale),
        dir: dir(),
        speed: rnd(...(ready?speedRangeReady:speedRangeIdle)),
        phase: Math.random()*Math.PI*2,
        amp: rnd(...vertAmpRange),
        freq: rnd(...vertFreqRange)*Math.PI*2,
        level: lev,
        centerY: centerY(lev, pondTop, pondH),
      }; fishState.set(f.id, s);
    } else {
      if (lev!==s.level) { s.level=lev; s.centerY=centerY(lev, pondTop, pondH); s.amp=rnd(...vertAmpRange); }
      const target = rnd(...(ready?speedRangeReady:speedRangeIdle));
      s.speed = s.speed*0.85 + target*0.15;
    }
    return s;
  };

  const frameIdx=(t,speed,ready)=> {
    const base= ready?8:6, plus=Math.min(6, speed/14);
    return Math.floor(t*(base+plus)) % FRAMES;
  };

  const drawSprite=(ctx,img,sx,sy,sw,sh,dx,dy,flipX,scale,gray,alpha)=>{
    ctx.save();
    ctx.translate(dx,dy);
    if (flipX) ctx.scale(-1,1);
    ctx.imageSmoothingEnabled=false;
    if (gray && useGrayscaleFilter){ ctx.filter='grayscale(100%) saturate(0%) brightness(85%)'; ctx.globalAlpha=alpha; }
    else if (gray){ ctx.globalAlpha=alpha; }
    ctx.drawImage(img,sx,sy,sw,sh, -sw*0.5*scale, -sh*0.5*scale, sw*scale, sh*scale);
    if (gray && useGrayscaleFilter) ctx.filter='none';
    ctx.restore();
  };

  return {
    id:'fishes', order:20,
    draw:(frame,getState)=>{
      const {ctx,t,dt,w,h,pondTop}=frame;
      const gs = getState?.() || {};
      const fishes = gs.fishes || [];
      const fishing = gs.fishing || {};
      const dialogOpen = !!gs.dialog?.open;
      if(!fishes.length) return;

      const pondH = Math.max(0, h-pondTop);
      const sheet = Assets.get(sheetKey);

      fishes.forEach((f)=>{
        const ready = !!f.ready;
        const s = ensure(f, w, pondTop, pondH, ready);

        let override=false;

        if (fishing?.targetFishId===f.id && fishing?.phase){
          // цель рыбалки
          if (fishing.phase==='luring'){
            const tx=fishing.hookX, ty=fishing.hookY;
            const dy = ty - (s.centerY);
            const dx = tx - s.x;
            const dist = Math.hypot(dx,dy);
            if (dist>1e-3){
              s.x += (dx/dist)*lureSpeedBoost*dt;
              s.centerY += (dy/dist)*lureSpeedBoost*dt;
            }
            if (dist <= lureSnapDist && gs.setFishing){
              gs.setFishing(prev=> prev?.phase==='luring'? {...prev, phase:'reeling'} : prev);
            }
            override=true;
          } else if (fishing.phase==='reeling' || (fishing.phase==='done' && dialogOpen)){
            // висим на крючке и во время подъёма, и пока открыт диалог
            s.x = fishing.hookX;
            s.centerY = fishing.hookY + 10;
            override=true;
          }
        }

        if (!override){
          s.x += s.dir * s.speed * dt;
          const halfW = (SPR_W*scale)*0.5;
          const leftLimit = leftMargin + halfW;
          const rightLimit = w - rightMargin - halfW;
          if (s.x<=leftLimit){ s.x=leftLimit; s.dir=1; }
          else if (s.x>=rightLimit){ s.x=rightLimit; s.dir=-1; }

          const [yMin,yMax] = rangeY(s.level, pondTop, pondH);
          const yOsc = Math.sin(t*s.freq + s.phase)*s.amp;
          let ny = s.centerY + yOsc;
          if (ny<yMin) ny=yMin; if (ny>yMax) ny=yMax;
          s.centerY = s.centerY*0.9 + ny*0.1;
        }

        const row = Math.min(2, Math.max(0, s.level));
        const col = frameIdx(t, s.speed, ready);
        const sx = col*SPR_W, sy=row*SPR_H;
        const flipX = (s.dir > 0); // фикс: теперь не «задом наперёд»

        if (sheet){
          if (ready) drawSprite(ctx, sheet, sx, sy, SPR_W, SPR_H, s.x, s.centerY, flipX, scale, false, 1);
          else       drawSprite(ctx, sheet, sx, sy, SPR_W, SPR_H, s.x, s.centerY, flipX, scale, true, 0.85);
        } else {
          ctx.save(); ctx.fillStyle= ready?'#FFD54F':'rgba(180,180,180,0.8)';
          ctx.beginPath(); ctx.arc(s.x, s.centerY, SPR_H*0.6, 0, Math.PI*2); ctx.fill(); ctx.restore();
        }
      });
    }
  };
}


## src/layers/fishingLine.js

const easeOutCubic = (p)=>1-Math.pow(1-p,3);

export default function createFishingLineLayer(options={}) {
  const { lineColor='rgba(230,230,230,0.9)', hookColor='#cfd8dc', hookSize=8, castDuration=700, reelDuration=900 } = options;
  let castStart=null, reelStart=null, targetDepthY=null;

  return {
    id:'fishing-line', order:27,
    draw:(frame,getState)=>{
      const {ctx,t,w,h,pondTop}=frame;
      const gs = getState?.() || {};
      const { fishing, setFishing, setDialog, fishes, getWaveFn, dialog } = gs;
      const waveFn = getWaveFn?.() || ((time,x,fr)=>(fr?.pondTop??pondTop));

      if (!fishing || fishing.phase==='idle') { castStart=null; reelStart=null; targetDepthY=null; return; }

      const boatX = fishing.boatX ?? (w*0.5);
      const anchorY = waveFn(t, boatX, frame) - 6;

      if (fishing.phase==='casting' && castStart===null){
        const fish = fishes?.find(ff=>ff.id===fishing.targetFishId);
        const lev = Math.min(3, Math.max(0, (fish?.depth_level??0)|0));
        const L = (h-pondTop)/4;
        const top = pondTop + lev*L, bot = pondTop + (lev+1)*L;
        targetDepthY = (top+bot)*0.5;
        castStart = performance.now();
      }

      let hookX=boatX, hookY=anchorY+20;

      if (fishing.phase==='casting'){
        const p = Math.min(1, (performance.now()-castStart)/castDuration);
        const k = easeOutCubic(p);
        hookY = anchorY + (targetDepthY - anchorY)*k;
        if (p>=1) setFishing(prev=>({...prev, phase:'luring', hookX, hookY}));

      } else if (fishing.phase==='luring'){
        hookY = targetDepthY;

      } else if (fishing.phase==='reeling'){
        if (reelStart===null) reelStart=performance.now();
        const p = Math.min(1, (performance.now()-reelStart)/reelDuration);
        const k = easeOutCubic(p);
        hookY = targetDepthY + (anchorY - targetDepthY)*k;
        if (p>=1){
          const fish = fishes?.find(ff=>ff.id===fishing.targetFishId);
          setDialog && setDialog({ open:true, fish, sessionId:fishing.sessionId });
          setFishing(prev=>({...prev, phase:'done', hookX, hookY }));
        }

      } else if (fishing.phase==='done'){
        hookY = anchorY; // у лодки; координаты публикуем для «привязки» рыбы
      }

      setFishing(prev=> (prev?.phase? { ...prev, hookX, hookY } : prev));

      ctx.save();
      ctx.strokeStyle=lineColor; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(boatX, anchorY); ctx.lineTo(hookX, hookY); ctx.stroke();
      ctx.fillStyle=hookColor; ctx.beginPath(); ctx.arc(hookX, hookY, hookSize*0.2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.moveTo(hookX, hookY + hookSize*0.2); ctx.lineTo(hookX + 4, hookY + 6); ctx.strokeStyle=hookColor; ctx.stroke();
      ctx.restore();
    }
  };
}


## src/layers/boat.js

export default function createBoatLayer() {
  const hullOffset=10, tiltScale=0.04;
  return {
    id:'boat', order:30,
    draw:(frame,getState)=>{
      const {ctx,t,w} = frame;
      const { boat, getWaveFn } = getState?.() || {};
      const x = boat?.x ?? w*0.5;
      const waveFn = getWaveFn?.() || ((time,x)=>frame.pondTop);
      const ySurf = waveFn(t, x, frame);
      const yL = waveFn(t, x-1, frame), yR = waveFn(t, x+1, frame);
      const angle = Math.atan((yR-yL)/2)*tiltScale;
      const y = ySurf - hullOffset;

      ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
      ctx.fillStyle='#4E342E';
      ctx.beginPath(); ctx.moveTo(-40,0); ctx.lineTo(40,0); ctx.lineTo(30,12); ctx.lineTo(-30,12); ctx.closePath(); ctx.fill();
      ctx.strokeStyle='#1B1B1B'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(0,-22); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,-16); ctx.lineTo(50,-40); ctx.stroke();
      ctx.restore();
    }
  };
}


## src/components/FishingDialog.jsx

import React, { useEffect, useState, useCallback } from 'react';
import { usePond } from '../context/PondContext';
import { fishService } from '../../services/fishService';
import { sessionService } from '../../services/sessionService';

export default function FishingDialog() {
  const { dialog, setDialog, resetFishing, fishes, setFishes } = usePond();
  const [score, setScore] = useState(null);
  const [submitting, setSubmitting] = useState(false);
  const fish = dialog?.fish || null;

  useEffect(()=>{ if(dialog.open){ setScore(null); setSubmitting(false);} },[dialog.open]);

  const closeAndReset=()=>{ setDialog({open:false, fish:null, sessionId:null}); resetFishing(); };

  const handleSubmit=async()=>{
    if (score==null || submitting || !fish) return;
    setSubmitting(true);
    try{
      const updated = await fishService.reviewFish(fish.id, { score });
      const idx = fishes.findIndex(x=>String(x.id)===String(fish.id));
      if (idx!==-1){ const next=fishes.slice(); next[idx]=updated; setFishes(next); }
      if (dialog.sessionId){ await sessionService.end(dialog.sessionId,{fishes_caught:1, session_score:score}); }
    }catch(e){ console.error(e); }
    finally{ setSubmitting(false); closeAndReset(); }
  };

  const handleCancel=()=>{ if(!submitting) closeAndReset(); };

  const onKey=useCallback((e)=>{
    if(!dialog.open) return;
    if (e.key>='1' && e.key<='4') setScore(Number(e.key));
    else if (e.key==='Enter' && score!=null && !submitting) handleSubmit();
    else if (e.key==='Escape' && !submitting) handleCancel();
  },[dialog.open, score, submitting]);

  useEffect(()=>{ window.addEventListener('keydown', onKey); return ()=>window.removeEventListener('keydown', onKey); },[onKey]);

  if (!dialog.open || !fish) return null;

  return (
    <div className="fixed inset-0 z-[100] bg-black/50 flex items-center justify-center p-4">
      <div className="w-full max-w-xl bg-white rounded-lg shadow-lg p-6">
        <h2 className="text-xl font-semibold mb-2">Оцените вспоминание</h2>

        <div className="mb-3">
          <div className="text-sm text-gray-500">Вопрос</div>
          <div className="font-medium text-gray-900 whitespace-pre-wrap">{fish.question || '—'}</div>
        </div>

        <div className="mb-4">
          <div className="text-sm text-gray-500">Ответ</div>
          <div className="p-3 bg-gray-50 rounded text-gray-800 whitespace-pre-wrap">{fish.answer || '—'}</div>
        </div>

        <div className="mb-4">
          <div className="font-semibold mb-2">Насколько хорошо вы вспомнили?</div>
          <div className="grid grid-cols-4 gap-2">
            {[1,2,3,4].map(v=>(
              <button key={v} onClick={()=>setScore(v)} disabled={submitting}
                className={`py-2 rounded border ${score===v?'bg-blue-600 text-white border-blue-600':'bg-white hover:bg-gray-50'}`}>
                {v}
              </button>
            ))}
          </div>
          <p className="text-xs text-gray-500 mt-2">Горячие клавиши: 1–4, Enter — отправить, Esc — отмена.</p>
        </div>

        <div className="flex justify-end gap-2">
          <button onClick={handleCancel} disabled={submitting} className="px-4 py-2 rounded border hover:bg-gray-50 disabled:opacity-50">Отмена</button>
          <button onClick={handleSubmit} disabled={score==null||submitting} className="px-4 py-2 rounded bg-blue-600 text-white disabled:opacity-50">
            {submitting?'Сохраняю…':'Сохранить'}
          </button>
        </div>
      </div>
    </div>
  );
}


## src/utils/assets.js

export const Assets = {
  images:{},
  loadImage(key, src){
    if (this.images[key]) return Promise.resolve(this.images[key]);
    return new Promise((resolve,reject)=>{
      const img=new Image();
      img.onload=()=>{ this.images[key]=img; resolve(img); };
      img.onerror=reject;
      img.src=src;
    });
  },
  get(key){ return this.images[key]; }
};


## src/data/mockData.js

export const mockPonds = [
  {
    id: 1,
    name: "Математический анализ",
    description: "Пределы, производные, интегралы",
    topic: "Математика",
    created_at: "2024-01-15",
    updated_at: "2024-01-20"
  },
  {
    id: 2,
    name: "Физика квантовых процессов",
    description: "Квантовая механика и термодинамика",
    topic: "Физика",
    created_at: "2024-01-10",
    updated_at: "2024-01-18"
  }
];

export const mockFishes = [
  {
    id: 1,
    pond_id: 1,
    question: "Что такое производная функции?",
    ready: false,
    answer: "Производная функции в точке — это скорость изменения функции в этой точке.",
    depth_level: 1,
    status: "new"
  },
  {
    id: 2,
    pond_id: 1,
    ready: true,
    question: "Формула Ньютона-Лейбница",
    answer: "∫ₐᵇ f(x)dx = F(b) - F(a), где F — первообразная f",
    depth_level: 2,
    status: "reviewing"
  },
  {
    id: 3,
    pond_id: 1,
    question: "Определение предела функции",
    answer: "Число A называется пределом функции f(x) при x→a, если для любого ε>0 существует δ>0 такое, что |f(x)-A|<ε при 0<|x-a|<δ",
    ready: true,
    depth_level: 3,
    status: "mastered"
  },
  {
    id: 4,
    pond_id: 2,
    question: "Принцип неопределенности Гейзенберга",
    answer: "Δx·Δp ≥ ℏ/2, где Δx — неопределенность координаты, Δp — импульса",
    ready: false,
    depth_level: 1,
    status: "new"
  }
];

## src/services/pondService.js

import { mockPonds } from '../data/mockData';

export const pondService = {
  getAllPonds: () => {
    return new Promise((resolve) => {
      setTimeout(() => resolve(mockPonds), 500);
    });
  },
  getPondById: (id) => {
    return new Promise((resolve) => {
      setTimeout(() => resolve(mockPonds.find(pond => pond.id === parseInt(id))), 500);
    });
  }
};


## src/components/Pond.jsx

import React, { useEffect, useMemo, useState } from 'react';
import { PondProvider, usePond } from '../context/PondContext';
import CanvasStage from '../components/CanvasStage';
import createWaterSurfaceLayer from '../layers/waterSurface';
import createUnderwaterBackLayer from '../layers/underwaterBack';
import createUnderwaterFrontLayer from '../layers/underwaterFront';
import createFishesLayer from '../layers/fishes';
import createFishingLineLayer from '../layers/fishingLine';
import createBoatLayer from '../layers/boat';
import FishingDialog from '../components/FishingDialog';
import { pondService } from '../../services/pondService';
import { fishService } from '../../services/fishService';
import { sessionService } from '../../services/sessionService';
import { Assets } from '../utils/assets';

function PondInner({ pondId }) {
  const { pond, setPond, fishes, setFishes, getState, fishing, setFishing, boat, dialog } = usePond();
  const [loading, setLoading] = useState(true);

  useEffect(()=>{
    let cancelled=false;
    (async()=>{
      try{
        setLoading(true);
        await Assets.loadImage('fishSheet','/assets/fish_spritesheet_px.png').catch(()=>{});
        const [p, fs]= await Promise.all([ pondService.getPondById(pondId), fishService.getFishesByPondId(pondId) ]);
        if(!cancelled){ setPond(p); setFishes(fs); }
      }catch(e){ console.error(e); }
      finally{ if(!cancelled) setLoading(false); }
    })();
    return ()=>{ cancelled=true; };
  },[pondId, setPond, setFishes]);

  const layers = useMemo(()=>[
    createWaterSurfaceLayer(),
    createUnderwaterBackLayer({ enableGradient:true, enableVegetation:true }),
    createFishesLayer(),
    createUnderwaterFrontLayer({ enableDepthFog:true, enableMotes:true, enableBubbles:true }),
    createFishingLineLayer(),
    createBoatLayer(),
  ],[]);

  const startFishing = async ()=>{
    try{
      if (fishing.phase!=='idle' || dialog.open) return;
      const session = await sessionService.start();
      const nextFish = await fishService.getNextFish();
      setFishing(prev=>({
        ...prev,
        sessionId: session.id,
        phase: 'casting',
        targetFishId: nextFish.id,
        boatX: boat?.x ?? window.innerWidth*0.5,
        hookX: null, hookY: null,
      }));
    }catch(e){ console.error(e); }
  };

  if (loading) return <div className="p-8 text-center">Загрузка пруда...</div>;
  if (!pond)   return <div className="p-8 text-center text-red-500">Пруд не найден</div>;

  const canStart = fishing.phase==='idle' && !dialog.open;

  return (
    <>
      <CanvasStage skyRatio={0.12} layers={layers} getState={getState}/>
      {canStart && (
        <button onClick={startFishing} className="fixed top-4 left-4 z-[60] bg-white/85 hover:bg-white text-slate-800 px-4 py-2 rounded shadow">
          Начать рыбалку
        </button>
      )}
      <FishingDialog/>
    </>
  );
}

export default function Pond({ pondId }) {
  return (
    <PondProvider>
      <PondInner pondId={pondId}/>
    </PondProvider>
  );
}

